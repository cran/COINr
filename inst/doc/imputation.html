<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Imputation</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Imputation</h1>



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Imputation is the process of estimating missing data points. To get
started with imputation, a reasonable first step is to see how much
missing data we have in the data set. We begin by building the example
coin, up the point of assembling the coin, but not any further:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(COINr)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>ASEM <span class="ot">&lt;-</span> <span class="fu">build_example_coin</span>(<span class="at">up_to =</span> <span class="st">&quot;new_coin&quot;</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>To check missing data, the <code>get_data_avail()</code> function can
be used. It can output to either the coin or to a list – here we output
to a list to readily display the results.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>l_avail <span class="ot">&lt;-</span> <span class="fu">get_data_avail</span>(ASEM, <span class="at">dset =</span> <span class="st">&quot;Raw&quot;</span>, <span class="at">out2 =</span> <span class="st">&quot;list&quot;</span>)</span></code></pre></div>
<p>The output list has data availability by unit:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(l_avail<span class="sc">$</span>Summary)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    uCode N_missing N_zero N_miss_or_zero Dat_Avail  Non_Zero</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 31   AUS         0      3              3 1.0000000 0.9387755</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1    AUT         0      2              2 1.0000000 0.9591837</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2    BEL         0      2              2 1.0000000 0.9591837</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 32   BGD         6      1              7 0.8775510 0.9767442</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3    BGR         0      0              0 1.0000000 1.0000000</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 33   BRN        10      2             12 0.7959184 0.9487179</span></span></code></pre></div>
<p>The lowest data availability by unit is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">min</span>(l_avail<span class="sc">$</span>Summary<span class="sc">$</span>Dat_Avail)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.7959184</span></span></code></pre></div>
<p>We can also check data availability by indicator. This is done by
calling <code>get_stats()</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>df_avail <span class="ot">&lt;-</span> <span class="fu">get_stats</span>(ASEM, <span class="at">dset =</span> <span class="st">&quot;Raw&quot;</span>, <span class="at">out2 =</span> <span class="st">&quot;df&quot;</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df_avail[<span class="fu">c</span>(<span class="st">&quot;iCode&quot;</span>, <span class="st">&quot;N.Avail&quot;</span>, <span class="st">&quot;Frc.Avail&quot;</span>)], <span class="dv">10</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       iCode N.Avail Frc.Avail</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1       LPI      51     1.000</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2   Flights      51     1.000</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3      Ship      51     1.000</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4      Bord      51     1.000</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5      Elec      51     1.000</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 6       Gas      51     1.000</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 7  ConSpeed      43     0.843</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 8     Cov4G      51     1.000</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 9     Goods      51     1.000</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 10 Services      51     1.000</span></span></code></pre></div>
<p>By indicator, the minimum data availability is:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">min</span>(df_avail<span class="sc">$</span>Frc.Avail)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.843</span></span></code></pre></div>
<p>With missing data, several options are available:</p>
<ol style="list-style-type: decimal">
<li>Leave it as it is and aggregate anyway (there is also the option for
data availability thresholds during aggregation - see <a href="aggregate.html">Aggregation</a>)</li>
<li>Consider removing indicators that have low data availability (this
has to be done manually because it affects the structure of the
index)</li>
<li>Consider removing units that have low data availability (see <a href="screening.html">Unit Screening</a>)</li>
<li>Impute missing data</li>
</ol>
<p>These options can also be combined. Here, we focus on the option of
imputation.</p>
</div>
<div id="data-frames" class="section level1">
<h1>Data frames</h1>
<p>The <code>Impute()</code> function is a flexible function that
imputes missing data in a data set using any suitable function that can
be passed to it. In fact, <code>Impute()</code> is a <em>generic</em>,
and has methods for coins, data frames, numeric vectors and purses.</p>
<p>Let’s begin by examining the data frame method of
<code>Impute()</code>, since it is easier to see what’s going on. We
will use a small data frame which is easy to visualise:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># some data to use as an example</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># this is a selected portion of the data with some missing values</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>df1 <span class="ot">&lt;-</span>  ASEM_iData[<span class="dv">37</span><span class="sc">:</span><span class="dv">46</span>, <span class="dv">36</span><span class="sc">:</span><span class="dv">39</span>]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(df1, <span class="at">row.names =</span> <span class="cn">FALSE</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    Pat CultServ CultGood Tourist</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   23.7  0.13405       NA  11.519</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  583.5  2.20754   16.182  24.040</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    3.6  0.05780    0.985   6.509</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  249.8  1.79800       NA  17.242</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;     NA       NA       NA   3.315</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   64.2  1.15292    7.555  26.757</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    0.3  0.00266    0.046   0.404</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;     NA  0.08905       NA   2.907</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   46.5  0.34615    1.213   3.370</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    7.2  0.03553    1.256   0.966</span></span></code></pre></div>
<p>In the simplest case, imputation can be performed column-wise,
i.e. by imputing each indicator one at a time:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">Impute</span>(df1, <span class="at">f_i =</span> <span class="st">&quot;i_mean&quot;</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       Pat  CultServ CultGood Tourist</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 37  23.70 0.1340500   4.5395  11.519</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 38 583.50 2.2075400  16.1820  24.040</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 39   3.60 0.0578000   0.9850   6.509</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 40 249.80 1.7980000   4.5395  17.242</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 41 122.35 0.6470778   4.5395   3.315</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 42  64.20 1.1529200   7.5550  26.757</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 43   0.30 0.0026600   0.0460   0.404</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 44 122.35 0.0890500   4.5395   2.907</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 45  46.50 0.3461500   1.2130   3.370</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 46   7.20 0.0355300   1.2560   0.966</span></span></code></pre></div>
<p>Here, the “Raw” data set has been imputed by substituting missing
values with the mean of the non-<code>NA</code> values for each column.
This is performed by setting <code>f_i = &quot;i_mean&quot;</code>. The
<code>f_i</code> argument refers to a function that imputes a numeric
vector - in this case the built-in <code>i_mean()</code> function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># demo of i_mean() function, which is built in to COINr</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>, <span class="cn">NA</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">i_mean</span>(x)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1.0 2.0 3.0 4.0 2.5</span></span></code></pre></div>
<p>The key concept here is that the simple function
<code>i_mean()</code> is applied by <code>Impute()</code> to each
column. This idea of passing simpler functions is used in several key
COINr functions, and allows great flexibility because more sophisticated
imputation methods can be used from other packages, for example.</p>
<p>For now let’s explore the options native to COINr. We can also apply
the <code>i_median()</code> function in the same way to substitute with
the indicator median. Adding a little complexity, we can also impute by
mean or median, but within unit (row) groups. Let’s assume that the
first five rows in our data frame belong to a group “a”, and the
remaining five to a different group “b”. In practice, these could be
e.g. GDP, population or wealth groups for countries - we might
hypothesise that it is better to replace <code>NA</code> values with the
median inside a group, rather than the overall median, because countries
within groups are more similar.</p>
<p>To do this on a data frame we can use the <code>i_median_grp()</code>
function, which requires an additional argument <code>f</code>: a
grouping variable. This is passed through <code>Impute()</code> using
the <code>f_i_para</code> argument which takes any additional parameters
top <code>f_i</code> apart from the data to be imputed.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># row grouping</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>groups <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">&quot;a&quot;</span>, <span class="dv">5</span>), <span class="fu">rep</span>(<span class="st">&quot;b&quot;</span>, <span class="dv">5</span>))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># impute</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>dfi2 <span class="ot">&lt;-</span> <span class="fu">Impute</span>(df1, <span class="at">f_i =</span> <span class="st">&quot;i_median_grp&quot;</span>, <span class="at">f_i_para =</span> <span class="fu">list</span>(<span class="at">f =</span> groups))</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># display</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(dfi2, <span class="at">row.names =</span> <span class="cn">FALSE</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;     Pat CultServ CultGood Tourist</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   23.70 0.134050   8.5835  11.519</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  583.50 2.207540  16.1820  24.040</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    3.60 0.057800   0.9850   6.509</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  249.80 1.798000   8.5835  17.242</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  136.75 0.966025   8.5835   3.315</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   64.20 1.152920   7.5550  26.757</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    0.30 0.002660   0.0460   0.404</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   26.85 0.089050   1.2345   2.907</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   46.50 0.346150   1.2130   3.370</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    7.20 0.035530   1.2560   0.966</span></span></code></pre></div>
<p>The <code>f_i_para</code> argument requires a named list of
additional parameter values. This allows functions of any complexity to
be passed to <code>Impute()</code>. By default, <code>Impute()</code>
applies <code>f_i</code> to each column of data, so <code>f_i</code> is
expected to take a numeric vector as its first input, and specifically
have the format <code>function(x, f_i_para)</code> where <code>x</code>
is a numeric vector and <code>...</code> are further arguments. This
means that the first argument of <code>f_i</code> <em>must</em> be
called “x”. To use functions that don’t have <code>x</code> as a first
argument, you would have to write a wrapper function.</p>
<p>Other than imputing by column, we can also impute by row. This only
really makes sense if the indicators are on a common scale, i.e. if they
are normalised first (or perhaps if they already share the same units).
To impute by row, set <code>impute_by = &quot;row&quot;</code>. In our example
data set we have indicators on rather different scales. Let’s see what
happens if we impute by row mean but <em>don’t</em> normalise:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">Impute</span>(df1, <span class="at">f_i =</span> <span class="st">&quot;i_mean&quot;</span>, <span class="at">impute_by =</span> <span class="st">&quot;row&quot;</span>, <span class="at">normalise_first =</span> <span class="cn">FALSE</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           Pat CultServ  CultGood Tourist</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 37  23.700000  0.13405 11.784350  11.519</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 38 583.500000  2.20754 16.182000  24.040</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 39   3.600000  0.05780  0.985000   6.509</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 40 249.800000  1.79800 89.613333  17.242</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 41   3.315000  3.31500  3.315000   3.315</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 42  64.200000  1.15292  7.555000  26.757</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 43   0.300000  0.00266  0.046000   0.404</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 44   1.498025  0.08905  1.498025   2.907</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 45  46.500000  0.34615  1.213000   3.370</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 46   7.200000  0.03553  1.256000   0.966</span></span></code></pre></div>
<p>This imputes some silly values, particularly in “CultGood”, because
“Pat” has much higher values. Clearly this is not a sensible strategy,
unless all indicators are on the same scale. We can however normalise
first, impute, then return indicators to their original scales:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">Impute</span>(df1, <span class="at">f_i =</span> <span class="st">&quot;i_mean&quot;</span>, <span class="at">impute_by =</span> <span class="st">&quot;row&quot;</span>, <span class="at">normalise_first =</span> <span class="cn">TRUE</span>, <span class="at">directions =</span> <span class="fu">rep</span>(<span class="dv">1</span>,<span class="dv">4</span>))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;          Pat CultServ  CultGood Tourist</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 37  23.70000 0.134050  2.850908  11.519</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 38 583.50000 2.207540 16.182000  24.040</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 39   3.60000 0.057800  0.985000   6.509</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 40 249.80000 1.798000 10.163326  17.242</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 41  64.72133 0.246215  1.828412   3.315</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 42  64.20000 1.152920  7.555000  26.757</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 43   0.30000 0.002660  0.046000   0.404</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 44  39.42134 0.089050  1.128411   2.907</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 45  46.50000 0.346150  1.213000   3.370</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 46   7.20000 0.035530  1.256000   0.966</span></span></code></pre></div>
<p>This additionally required to specify the <code>directions</code>
argument because we need to know which direction each indicator runs in
(whether they are positive or negative indicators). In our case all
indicators are positive. See the vignette on <a href="normalise.html">Normalisation</a> for more details on indicator
directions.</p>
<p>The values imputed in this way are more realistic. Essentially we are
replacing each missing value with the average (normalised) score of the
other indicators, for a given unit. However this also only makes sense
if the indicators/columns are similar to one another: high values of one
would likely imply high values in the other.</p>
<p>Behind the scenes, setting <code>normalise_first = TRUE</code> first
normalises each column using a min-max method, then performs the
imputation, then returns the indicators to the original scales using the
inverse transformation. Another approach which gives more control is to
simply run <code>Normalise()</code> first, and work with the normalised
data from that point onwards. In that case it is better to set
<code>normalise_first = FALSE</code>, since by default if
<code>impute_by = &quot;row&quot;</code> it will be set to <code>TRUE</code>.</p>
<p>As a final point on data frames, we can set
<code>impute_by = &quot;df&quot;</code> to pass the entire data frame to
<code>f_i</code>, which may be useful for more sophisticated
multivariate imputation methods. But what’s the point of using
<code>Impute()</code> then, you may ask? First, because when imputing
coins, we can impute by indicator groups (see next section); and second,
<code>Impute()</code> performs some checks to ensure that
non-<code>NA</code> values are not altered.</p>
</div>
<div id="coins" class="section level1">
<h1>Coins</h1>
<p>Imputing coins is similar to imputing data frames because the coin
method of <code>Impute()</code> calls the data frame method. Please read
that section first if you have not already done so. However, for coins
there are some additional function arguments.</p>
<p>In the simple case we impute a named data set <code>dset</code> using
the function <code>f_i</code>: e.g. if we want to impute the “Raw” data
set using indicator median values:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>ASEM <span class="ot">&lt;-</span> <span class="fu">Impute</span>(ASEM, <span class="at">dset =</span> <span class="st">&quot;Raw&quot;</span>, <span class="at">f_i =</span> <span class="st">&quot;i_mean&quot;</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>ASEM</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; --------------</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; A coin with...</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; --------------</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Input:</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Units: 51 (AUS, AUT, BEL, ...)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Indicators: 49 (Goods, Services, FDI, ...)</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Denominators: 4 (Area, Energy, GDP, ...)</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Groups: 4 (GDP_group, GDPpc_group, Pop_group, ...)</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Structure:</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Level 1 Indicator: 49 indicators (FDI, ForPort, Goods, ...) </span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Level 2 Pillar: 8 groups (ConEcFin, Instit, P2P, ...) </span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Level 3 Sub-index: 2 groups (Conn, Sust) </span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Level 4 Index: 1 groups (Index) </span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Data sets:</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Raw (51 units)</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Imputed (51 units)</span></span></code></pre></div>
<p>Here, <code>Impute()</code> extracts the “Raw” data set as a data
frame, imputes it using the data frame method (see previous section),
then saves it as a new data set in the coin. Here, the data set is
called “Imputed” but can be named otherwise using the
<code>write_to</code> argument.</p>
<p>We can also impute by group using a grouped imputation function.
Since unit groups are stored within the coin (variables labelled as
“Group” in <code>iMeta</code>), these can be called directly using the
<code>use_group</code> argument (without having to specify the
<code>f_i_para</code> argument):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>ASEM <span class="ot">&lt;-</span> <span class="fu">Impute</span>(ASEM, <span class="at">dset =</span> <span class="st">&quot;Raw&quot;</span>, <span class="at">f_i =</span> <span class="st">&quot;i_mean_grp&quot;</span>, <span class="at">use_group =</span> <span class="st">&quot;GDP_group&quot;</span>, )</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; (overwritten existing data set)</span></span></code></pre></div>
<p>This has imputed each indicator using its GDP group mean.</p>
<p>Row-wise imputation works in the same way as with a data frame, by
setting <code>impute_by = &quot;row&quot;</code>. However, this is particularly
useful in conjunction with the <code>group_level</code> argument. If
this is specified, rather than imputing across the entire row of data,
it splits rows into indicator groups, using the structure of the index.
For example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>ASEM <span class="ot">&lt;-</span> <span class="fu">Impute</span>(ASEM, <span class="at">dset =</span> <span class="st">&quot;Raw&quot;</span>, <span class="at">f_i =</span> <span class="st">&quot;i_mean&quot;</span>, <span class="at">impute_by =</span> <span class="st">&quot;row&quot;</span>,</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>               <span class="at">group_level =</span> <span class="dv">2</span>, <span class="at">normalise_first =</span> <span class="cn">TRUE</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; (overwritten existing data set)</span></span></code></pre></div>
<p>Here, the <code>group_level</code> argument specifies which
level-grouping of the indicators to use. In the ASEM example here, we
are using level 2 groups, so it is substituting missing values with the
average normalised score within each sub-pillar (in the ASEM example
level 2 is called “sub-pillars”).</p>
<p>Imputation in this way has an important relationship with
aggregation. This is because if we <em>don’t</em> impute, then in the
aggregation step, if we take the mean of a group of indicators, and
there is a <code>NA</code> present, this value is excluded from the mean
calculation. Doing this is mathematically equivalent to assigning the
mean to that missing value and then taking the mean of all of the
indicators. This is sometimes known as “shadow imputation”. Therefore,
one reason to use this imputation method is to see which values are
being implicitly assigned as a result of excluding missing values from
the aggregation step.</p>
</div>
<div id="purses" class="section level1">
<h1>Purses</h1>
<p>Purse imputation is very similar to coin imputation, because by
default the purse method of <code>Impute()</code> imputes each coin
separately. There is one exception to this: if
<code>f_i = &quot;impute_panel</code>, the data sets inside the purse are
imputed using the last available data point, using the
<code>impute_panel()</code> function. In this case, coins are not
imputed individually, but treated as a single data set. In this case,
optionally set <code>f_i_para = list(max_time = .)</code> where
<code>.</code> should be substituted with the maximum number of time
points to search backwards for a non-<code>NA</code> value. See
<code>impute_panel()</code> for more details. No further arguments need
to be passed to <code>impute_panel()</code>.</p>
<p>It is difficult to show this working without a contrived example, so
let’s contrive one. We take the example panel data set
<code>ASEM_iData_p</code>, and introduce a missing value <code>NA</code>
in the indicator “LPI” for unit “GB”, for year 2022.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># copy</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>dfp <span class="ot">&lt;-</span> ASEM_iData_p</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co"># create NA for GB in 2022</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>dfp<span class="sc">$</span>LPI[dfp<span class="sc">$</span>uCode <span class="sc">==</span> <span class="st">&quot;GB&quot;</span> <span class="sc">&amp;</span> dfp<span class="sc">$</span>Time <span class="sc">==</span> <span class="dv">2022</span>] <span class="ot">&lt;-</span> <span class="cn">NA</span></span></code></pre></div>
<p>This data point has a value for the previous year, 2021. Let’s see
what it is:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>dfp<span class="sc">$</span>LPI[dfp<span class="sc">$</span>uCode <span class="sc">==</span> <span class="st">&quot;GB&quot;</span> <span class="sc">&amp;</span> dfp<span class="sc">$</span>Time <span class="sc">==</span> <span class="dv">2021</span>]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; numeric(0)</span></span></code></pre></div>
<p>Now let’s build the purse and impute the raw data set.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># build purse</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>ASEMp <span class="ot">&lt;-</span> <span class="fu">new_coin</span>(dfp, ASEM_iMeta, <span class="at">split_to =</span> <span class="st">&quot;all&quot;</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># impute raw data using latest available value</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>ASEMp <span class="ot">&lt;-</span> <span class="fu">Impute</span>(ASEMp, <span class="at">dset =</span> <span class="st">&quot;Raw&quot;</span>, <span class="at">f_i =</span> <span class="st">&quot;impute_panel&quot;</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Imputed</span></span></code></pre></div>
<p>Now we check whether our imputed point is what we expect: we would
expect that our <code>NA</code> is now replaced with the 2021 value as
found previously. To get at the data we can use the
<code>get_data()</code> function.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">get_data</span>(ASEMp, <span class="at">dset =</span> <span class="st">&quot;Imputed&quot;</span>, <span class="at">iCodes =</span> <span class="st">&quot;LPI&quot;</span>, <span class="at">uCodes =</span> <span class="st">&quot;GBR&quot;</span>, <span class="at">Time =</span> <span class="dv">2021</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;     Time uCode      LPI</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 183 2021   GBR 4.386542</span></span></code></pre></div>
<p>And indeed this corresponds to what we expect.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
