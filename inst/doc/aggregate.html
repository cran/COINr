<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Aggregation</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Aggregation</h1>



<p>This vignette describes the process of aggregating indicators, in
COINr.</p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Aggregation is the operation of combining multiple indicators into
one value. Many composite indicators have a hierarchical structure, so
in practice this often involves multiple aggregations, for example
aggregating groups of indicators into aggregate values, then aggregating
those values into higher-level aggregates, and so on, until the final
index value.</p>
<p>Aggregating should almost always be done on normalised data, unless
the indicators are already on very similar scales. Otherwise the
relative influence of indicators will be very uneven.</p>
<p>Of course you don’t <em>have</em> to aggregate indicators at all, and
you might be content with a scoreboard, or perhaps aggregating into
several aggregate values rather than a single index. However, consider
that aggregation should not substitute the underlying indicator data,
but complement it.</p>
<p>Overall, aggregating indicators is a form of information compression
- you are trying to combine many indicator values into one, and
inevitably information will be lost<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. As long as this is kept in mind, and
indicator data is presented and made available along side aggregate
values, then aggregate (index) values can complement indicators and be
used as a useful tool for summarising the underlying data, and
identifying overall trends and patterns.</p>
<div id="weighting" class="section level2">
<h2>Weighting</h2>
<p>Many aggregation methods involve some kind of weighting,
i.e. coefficients that define the relative weight of the
indicators/aggregates in the aggregation. In order to aggregate, weights
need to first be specified, but to effectively adjust weights it is
necessary to aggregate.</p>
<p>This chicken and egg conundrum is best solved by aggregating
initially with a trial set of weights, perhaps equal weights, then
seeing the effects of the weighting, and making any weight adjustments
necessary.</p>
</div>
<div id="approaches" class="section level2">
<h2>Approaches</h2>
<div id="means" class="section level3">
<h3>Means</h3>
<p>The most straightforward and widely-used approach to aggregation is
the <strong>weighted arithmetic mean</strong>. Denoting the indicators
as <span class="math inline">\(x_i \in \{x_1, x_2, ... , x_d
\}\)</span>, a weighted arithmetic mean is calculated as:</p>
<p><span class="math display">\[ y = \frac{1}{\sum_{i=1}^d w_i}
\sum_{i=1}^d x_iw_i \]</span></p>
<p>where the <span class="math inline">\(w_i\)</span> are the weights
corresponding to each <span class="math inline">\(x_i\)</span>. Here, if
the weights are chosen to sum to 1, it will simplify to the weighted sum
of the indicators. In any case, the weighted mean is scaled by the sum
of the weights, so weights operate relative to each other.</p>
<p>Clearly, if the index has more than two levels, then there will be
multiple aggregations. For example, there may be three groups of
indicators which give three separate aggregate scores. These aggregate
scores would then be fed back into the weighted arithmetic mean above to
calculate the overall index.</p>
<p>The arithmetic mean has “perfect compensability”, which means that a
high score in one indicator will perfectly compensate a low score in
another. In a simple example with two indicators scaled between 0 and 10
and equal weighting, a unit with scores (0, 10) would be given the same
score as a unit with scores (5, 5) – both have a score of 5.</p>
<p>An alternative is the <strong>weighted geometric mean</strong>, which
uses the product of the indicators rather than the sum.</p>
<p><span class="math display">\[ y = \left( \prod_{i=1}^d x_i^{w_i}
\right)^{1 / \sum_{i=1}^d w_i} \]</span></p>
<p>This is simply the product of each indicator to the power of its
weight, all raised the the power of the inverse of the sum of the
weights.</p>
<p>The geometric mean is less compensatory than the arithmetic mean –
low values in one indicator only partially substitute high values in
others. For this reason, the geometric mean may sometimes be preferred
when indicators represent “essentials”. An example might be quality of
life: a longer life expectancy perhaps should not compensate severe
restrictions on personal freedoms.</p>
<p>A third type of mean, in fact the third of the so-called <a href="https://en.wikipedia.org/wiki/Pythagorean_means">Pythagorean
means</a> is the <strong>weighted harmonic mean</strong>. This uses the
mean of the reciprocals of the indicators:</p>
<p><span class="math display">\[ y = \frac{\sum_{i=1}^d
w_i}{\sum_{i=1}^d w_i/x_i} \]</span></p>
<p>The harmonic mean is the the least compensatory of the the three
means, even less so than the geometric mean. It is often used for taking
the mean of rates and ratios.</p>
</div>
<div id="other-methods" class="section level3">
<h3>Other methods</h3>
<p>The <em>weighted median</em> is also a simple alternative candidate.
It is defined by ordering indicator values, then picking the value which
has half of the assigned weight above it, and half below it. For
<em>ordered</em> indicators <span class="math inline">\(x_1, x_2, ...,
x_d\)</span> and corresponding weights <span class="math inline">\(w_1,
w_2, ..., w_d\)</span> the weighted median is the indicator value <span class="math inline">\(x_m\)</span> that satisfies:</p>
<p><span class="math display">\[ \sum_{i=1}^{m-1} w_i \leq \frac{1}{2},
\: \: \text{and} \sum_{i=m+1}^{d} w_i \leq \frac{1}{2} \]</span></p>
<p>The median is known to be robust to outliers, and this may be of
interest if the distribution of scores across indicators is skewed.</p>
<p>Another somewhat different approach to aggregation is to use the <a href="https://en.wikipedia.org/wiki/Copeland%27s_method">Copeland
method</a>. This approach is based pairwise comparisons between units
and proceeds as follows. First, an <em>outranking matrix</em> is
constructed, which is a square matrix with <span class="math inline">\(N\)</span> columns and <span class="math inline">\(N\)</span> rows, where <span class="math inline">\(N\)</span> is the number of units.</p>
<p>The element in the <span class="math inline">\(p\)</span>th row and
<span class="math inline">\(q\)</span>th column of the matrix is
calculated by summing all the indicator weights where unit <span class="math inline">\(p\)</span> has a higher value in those indicators
than unit <span class="math inline">\(q\)</span>. Similarly, the cell in
the <span class="math inline">\(q\)</span>th row and <span class="math inline">\(p\)</span>th column (which is the cell opposite on
the other side of the diagonal), is calculated as the sum of the weights
unit where <span class="math inline">\(q\)</span> has a higher value
than unit <span class="math inline">\(p\)</span>. If the indicator
weights sum to one over all indicators, then these two scores will also
sum to 1 by definition. The outranking matrix effectively summarises to
what extent each unit scores better or worse than all other units, for
all unit pairs.</p>
<p>The Copeland score for each unit is calculated by taking the sum of
the row values in the outranking matrix. This can be seen as an average
measure of to what extent that unit performs above other units.</p>
<p>Clearly, this can be applied at any level of aggregation and used
hierarchically like the other aggregation methods presented here.</p>
<p>In some cases, one unit may score higher than the other in all
indicators. This is called a <em>dominance pair</em>, and corresponds to
any pair scores equal to one (equivalent to any pair scores equal to
zero).</p>
<p>The percentage of dominance pairs is an indication of robustness.
Under dominance, there is no way methodological choices (weighting,
normalisation, etc.) can affect the relative standing of the pair in the
ranking. One will always be ranked higher than the other. The greater
the number of dominance (or robust) pairs in a classification, the less
sensitive country ranks will be to methodological assumptions. COINr
allows to calculate the percentage of dominance pairs with an inbuilt
function.</p>
</div>
</div>
</div>
<div id="coins" class="section level1">
<h1>Coins</h1>
<p>We now turn to how data sets in a coin can be aggregated using the
methods described previously. The function of interest,
<code>aggregate()</code> unfortunately masks base R’s identically-named
<code>aggregate()</code> function (which does something rather
different). To demonstrate COINr’s <code>aggregate()</code> function, we
begin by loading the package, and building the example coin, up to the
normalised data set.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(COINr)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># build example up to normalised data set</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>coin <span class="ot">&lt;-</span> <span class="fu">build_example_coin</span>(<span class="at">up_to =</span> <span class="st">&quot;Normalise&quot;</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; iData checked and OK.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; iMeta checked and OK.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Raw</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Denominated</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Imputed</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Screened</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Treated</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Normalised</span></span></code></pre></div>
<p>Consider what is needed to aggregate the normalised data into its
higher levels. We need:</p>
<ul>
<li>The data set to aggregate</li>
<li>The structure of the index: which indicators belong to which groups,
etc.</li>
<li>Weights to assign to indicators</li>
<li>Specifications for aggregation: an aggregation function (e.g. the
weighted mean) and any other parameters to be passed to that
function</li>
</ul>
<p>All of these elements are already present in the coin, except the
last. For the first point, we simply need to tell
<code>aggregate()</code> which data set to use (using the
<code>dset</code> argument). The structure of the index was defined when
building the coin in <code>new_coin()</code> (the <code>iMeta</code>
argument). Weights were also attached to <code>iMeta</code>. Finally,
specifications can be specified in the arguments of
<code>aggregate()</code>. Let’s begin with the simple case though: using
the function defaults.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># aggregate normalised data set</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>coin <span class="ot">&lt;-</span> <span class="fu">Aggregate</span>(coin, <span class="at">dset =</span> <span class="st">&quot;Normalised&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Aggregated</span></span></code></pre></div>
<p>By default, the aggregation function performs the following
steps:</p>
<ul>
<li>Uses the weights that were attached to <code>iMeta</code></li>
<li>Aggregates hierarchically (with default method of weighted
arithmetic mean), following the index structure specified in
<code>iMeta</code> and using the data specified in
<code>dset</code></li>
<li>Creates a new data set <code>.$Data$Aggregated</code>, which
consists of the data in <code>dset</code>, plus extra columns with
scores for each aggregation group, at each aggregation level.</li>
</ul>
<p>Let’s examine the new data set. The columns of each level are added
successively, working from level 1 upwards, so the highest aggregation
level (the index, here) will be the last column of the data frame.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>dset_aggregated <span class="ot">&lt;-</span> <span class="fu">get_dset</span>(coin, <span class="at">dset =</span> <span class="st">&quot;Aggregated&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>nc <span class="ot">&lt;-</span> <span class="fu">ncol</span>(dset_aggregated)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># view aggregated scores (last 11 columns here)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>dset_aggregated[(nc <span class="sc">-</span> <span class="dv">10</span>) <span class="sc">:</span> nc] <span class="sc">|&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>(<span class="dv">5</span>) <span class="sc">|&gt;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">signif</span>(<span class="dv">3</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   ConEcFin Environ Instit   P2P Physical Political Social SusEcFin Conn Sust</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1     12.6    31.9   52.4 39.50     34.8      52.5   71.9     55.7 38.4 53.2</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2     26.2    69.5   77.5 54.10     41.1      78.2   72.8     62.9 55.4 68.4</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3     48.2    53.0   75.6 43.30     72.0      80.8   86.2     50.1 64.0 63.1</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4     13.3    81.7   26.5  5.85     22.9      32.4   27.5     64.6 20.2 57.9</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5     24.6    55.7   75.9 27.10     28.4      67.5   53.3     61.7 44.7 56.9</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   Index</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1  45.8</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2  61.9</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3  63.5</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4  39.0</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5  50.8</span></span></code></pre></div>
<p>Here we see the level 2 aggregated scores created by aggregating each
group of indicators (the first eight columns), followed by the two
sub-indexes (level 3) created by aggregating the scores of level 2, and
finally the Index (level 4), which is created by aggregating the “Conn”
and “Sust” sub-indexes.</p>
<p>The format of this data frame is not hugely convenient for inspecting
the results. To see a more user-friendly version, use the
<code>get_results()</code> function. <em>TO ADD when this is
updated</em></p>
<div id="coinr-aggregation-functions" class="section level2">
<h2>COINr aggregation functions</h2>
<p>Let’s now explore some of the options of the <code>aggregate()</code>
function. Like other coin-building functions in COINr,
<code>aggregate()</code> comes with a number of inbuilt options, but can
also accept any function that is passed to it, as long as it satisfies
some requirements. COINr’s inbuilt aggregation functions begin with
<code>a_</code>, and are:</p>
<ul>
<li><code>a_amean()</code>: the weighted arithmetic mean</li>
<li><code>a_gmean()</code>: the weighted geometric mean</li>
<li><code>a_hmean()</code>: the weighted harmonic mean</li>
<li><code>a_copeland()</code>: the Copeland method (note: requires
<code>by_df = TRUE</code>)</li>
</ul>
<p>By default, the arithmetic mean is called but we can easily change
this to the geometric mean, for example. However here we run into a
problem: the geometric mean will fail if any values to aggregate are
less than or equal to zero. So to use the geometric mean we have to
re-do the normalisation step to avoid this. Luckily this is
straightforward in COINr:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>coin <span class="ot">&lt;-</span> <span class="fu">Normalise</span>(coin, <span class="at">dset =</span> <span class="st">&quot;Treated&quot;</span>,</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">global_specs =</span> <span class="fu">list</span>(<span class="at">f_n =</span> <span class="st">&quot;n_minmax&quot;</span>,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">f_n_para =</span> <span class="fu">list</span>(<span class="at">l_u =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">100</span>))))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Normalised</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; (overwritten existing data set)</span></span></code></pre></div>
<p>Now, since the indicators are scaled between 1 and 100 (instead of 0
and 100 as previously), they can be aggregated with the geometric
mean.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>coin <span class="ot">&lt;-</span> <span class="fu">Aggregate</span>(coin, <span class="at">dset =</span> <span class="st">&quot;Normalised&quot;</span>,</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">f_ag =</span> <span class="st">&quot;a_gmean&quot;</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Aggregated</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; (overwritten existing data set)</span></span></code></pre></div>
</div>
<div id="external-functions" class="section level2">
<h2>External functions</h2>
<p>All of the four aggregation functions mentioned above have the same
format (try e.g. <code>?a_gmean</code>), and are built into the COINr
package. But what if we want to use another type of aggregation
function? The process is exactly the same.</p>
<p>In this section we use some functions from other packages: the
matrixStats package and the Compind package. These are not imported by
COINr, so the code here will only work if you have these installed. If
this vignette was built on your computer, we have to check whether these
packages are installed:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ms_installed <span class="ot">&lt;-</span> <span class="fu">requireNamespace</span>(<span class="st">&quot;matrixStats&quot;</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ms_installed</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>ci_installed <span class="ot">&lt;-</span> <span class="fu">requireNamespace</span>(<span class="st">&quot;Compind&quot;</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>ci_installed</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>If either of these have returned <code>FALSE</code>, in the following
code chunks you will see some blanks. See the online version of this
vignette to see the results, or install the above packages and rebuild
the vignettes.</p>
<p>Now for an example, we can use the <code>weightedMedian()</code>
function from the matrixStats package. This has a number of arguments,
but the ones we will use are <code>x</code> and <code>w</code> (with the
same meanings as COINr functions), and <code>na.rm</code> which we need
to set to <code>TRUE</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># RESTORE above eval=ms_installed</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># load matrixStats package</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(matrixStats)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># aggregate using weightedMedian()</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>coin <span class="ot">&lt;-</span> <span class="fu">Aggregate</span>(coin, <span class="at">dset =</span> <span class="st">&quot;Normalised&quot;</span>,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                   <span class="at">f_ag =</span> <span class="st">&quot;weightedMedian&quot;</span>,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">f_ag_para =</span> <span class="fu">list</span>(<span class="at">na.rm =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<p>The weights <code>w</code> do not need to be specified in
<code>f_ag_para</code> because they are automatically passed to
<code>f_ag</code> unless specified otherwise.</p>
<p>The general requirements for <code>f_ag</code> functions passed to
<code>aggregate()</code> are that:</p>
<ol style="list-style-type: decimal">
<li>The input to the function is a numeric vector <code>x</code>,
possibly with missing values</li>
<li>The function returns a single (scalar) aggregated value</li>
<li>If the function accepts a vector of weights, this vector (of the
same length of <code>x</code>) is passed as function argument
<code>w</code>. If the function doesn’t accept a vector of weights, we
can set <code>w = &quot;none&quot;</code> in the arguments to
<code>aggregate()</code>, and it will not try to pass
<code>w</code>.</li>
<li>Any other arguments to <code>f_ag</code>, apart from <code>x</code>
and <code>w</code>, should be included in the named list
<code>f_ag_para</code>.</li>
</ol>
<p>Sometimes this may mean that we have to create a wrapper function to
satisfy these requirements. For example, the Compind package has a
number of sophisticated aggregation approaches. The “benefit of the
doubt” uses data envelopment analysis to aggregate indicators, however
the function <code>ci_bod()</code> outputs a list. We can make a wrapper
function to use this inside COINr:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># RESTORE ABOVE eval= ci_installed</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># load Compind</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="fu">suppressPackageStartupMessages</span>(<span class="fu">library</span>(Compind))</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># wrapper to get output of interest from ci_bod</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># also suppress messages about missing values</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>ci_bod2 <span class="ot">&lt;-</span> <span class="cf">function</span>(x){</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">suppressMessages</span>(<span class="fu">ci_bod</span>(x)<span class="sc">$</span>ci_bod_est)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co"># aggregate</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>coin <span class="ot">&lt;-</span> <span class="fu">Aggregate</span>(coin, <span class="at">dset =</span> <span class="st">&quot;Normalised&quot;</span>,</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>                   <span class="at">f_ag =</span> <span class="st">&quot;ci_bod2&quot;</span>, <span class="at">by_df =</span> <span class="cn">TRUE</span>, <span class="at">w =</span> <span class="st">&quot;none&quot;</span>)</span></code></pre></div>
<p>The benefit of the doubt approach automatically assigns individual
weights to each unit, so we need to specify <code>w = &quot;none&quot;</code> to
stop <code>aggregate()</code> from attempting to pass weights to the
function. Importantly, we also need to specify <code>by_df = TRUE</code>
which tells <code>aggregate()</code> to pass a data frame to
<code>f_ag</code> rather than a vector.</p>
</div>
<div id="data-availability-limits" class="section level2">
<h2>Data availability limits</h2>
<p>Many aggregation functions will return an aggregated value as long as
at least one of the values passed to it is non-<code>NA</code>. For
example, R’s <code>mean()</code> function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># data with all NAs except 1 value</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="cn">NA</span>, <span class="cn">NA</span>, <span class="cn">NA</span>, <span class="dv">1</span>, <span class="cn">NA</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(x)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] NA</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(x, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1</span></span></code></pre></div>
<p>Depending on how we set <code>na.rm</code>, we either get an answer
or <code>NA</code>, and this is the same for many other aggregation
functions (e.g. the ones built into COINr). Sometimes we might want a
bit more control. For example, if we have five indicators in a group, it
might only be reasonable to give an aggregated score if, say, at least
three out of five indicators have non-<code>NA</code> values.</p>
<p>The <code>aggregate()</code> function has the option to specify a
data availability limit when aggregating. We simply set
<code>dat_thresh</code> to a value between 0 and 1, and for each
aggregation group, any unit that has a data availability lower than
<code>dat_thresh</code> will get a <code>NA</code> value instead of an
aggregated score. This is most easily illustrated on a data frame (see
next section for more details on aggregating in data frames):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>df1 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">i1 =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">i2 =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="cn">NA</span>, <span class="cn">NA</span>),</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">i3 =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="cn">NA</span>, <span class="dv">1</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>df1</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   i1 i2 i3</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1  1  3  1</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2  2 NA NA</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3  3 NA  1</span></span></code></pre></div>
<p>We will require that at least 2/3 of the indicators should be
non-<code>NA</code> to give an aggregated value.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># aggregate with arithmetic mean, equal weight and data avail limit of 2/3</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">Aggregate</span>(df1, <span class="at">f_ag =</span> <span class="st">&quot;a_amean&quot;</span>,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">f_ag_para =</span> <span class="fu">list</span>(<span class="at">w =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)),</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>           <span class="at">dat_thresh =</span> <span class="dv">2</span><span class="sc">/</span><span class="dv">3</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1.666667       NA 2.000000</span></span></code></pre></div>
<p>Here we see that the second row is aggregated to give <code>NA</code>
because it only has 1/3 data availability.</p>
</div>
<div id="by-level" class="section level2">
<h2>By level</h2>
<p><em>TO ADD: changing by level</em></p>
</div>
</div>
<div id="data-frames" class="section level1">
<h1>Data frames</h1>
<p>The <code>aggregate()</code> function also works in the same way on
data frames. This is probably more useful when aggregation functions
take vectors as inputs, rather than data frames, since it would
otherwise be easier to go directly to the underlying function. In any
case, here are a couple of examples. First, using a built in COINr
function to compute the weighted harmonic mean of a data frame.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get some indicator data - take a few columns from built in data set</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> ASEM_iData[<span class="dv">12</span><span class="sc">:</span><span class="dv">15</span>]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># normalise to avoid zeros - min max between 1 and 100</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">Normalise</span>(X,</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">global_specs =</span> <span class="fu">list</span>(<span class="at">f_n =</span> <span class="st">&quot;n_minmax&quot;</span>,</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">f_n_para =</span> <span class="fu">list</span>(<span class="at">l_u =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">100</span>))))</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co"># aggregate using harmonic mean, with some weights</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">Aggregate</span>(X, <span class="at">f_ag =</span> <span class="st">&quot;a_hmean&quot;</span>, <span class="at">f_ag_para =</span> <span class="fu">list</span>(<span class="at">w =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>)))</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="fu">cbind</span>(X, y) <span class="sc">|&gt;</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>(<span class="dv">5</span>) <span class="sc">|&gt;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">signif</span>(<span class="dv">3</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    LPI Flights Ship Bord     y</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1 94.1   14.20  1.0 29.4  2.36</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2 94.6   15.60 97.2 40.0 41.50</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3 35.0    4.89 38.0 15.6 14.30</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4 51.2    4.90 59.2 34.3 17.40</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5 43.7    4.66 55.7  1.0  3.93</span></span></code></pre></div>
</div>
<div id="purses" class="section level1">
<h1>Purses</h1>
<p>The purse method for <code>aggregate()</code> is straightforward and
simply applies the same aggregation specifications to each of the coins
within. It has exactly the same parameters as the coin method.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># build example purse up to normalised data set</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>purse <span class="ot">&lt;-</span> <span class="fu">build_example_purse</span>(<span class="at">up_to =</span> <span class="st">&quot;Normalise&quot;</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># aggregate using defaults</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>purse <span class="ot">&lt;-</span> <span class="fu">Aggregate</span>(purse, <span class="at">dset =</span> <span class="st">&quot;Normalised&quot;</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Aggregated</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Aggregated</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Aggregated</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Aggregated</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Written data set to .$Data$Aggregated</span></span></code></pre></div>
</div>
<div id="what-next" class="section level1">
<h1>What next?</h1>
<p>After aggregating indicators, it is likely that you will want to
begin viewing and exploring the results. See the vignette on <a href="results.html">Exploring results</a> for more details.</p>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>This recent paper may be of interest: <a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
